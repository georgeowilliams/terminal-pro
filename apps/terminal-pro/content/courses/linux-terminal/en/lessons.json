[
  {
    "id": "mindset",
    "module": "0. Welcome",
    "title": "How terminal pros think",
    "tags": [
      "fundamentals",
      "workflow"
    ],
    "content": "\n<p>Becoming “terminal expert” is less about memorizing commands and more about building a <b>mental model</b>:</p>\n<ul>\n  <li><b>Everything is a file</b> (or a stream): config, devices, sockets, logs.</li>\n  <li><b>Small tools + pipes</b>: compose commands like LEGO.</li>\n  <li><b>Inspect first, then act</b>: preview before you delete/overwrite.</li>\n</ul>\n\n<pre>\nASCII model of streams + pipe composition:\n\nstdin(0) -> [ tool A ] -> [ tool B ] -> [ tool C ] -> stdout(1)\n                 |            |            |\n               flags       filters     formatters\n\nstderr(2) -------------------------------------> terminal\n\nRedirect patterns:\n  cmd > out.txt\n  cmd 2> err.txt\n  cmd > all.txt 2>&1\n</pre>\n\n<div class=\"hint\">\nCore pro habit: keep a scratch pad command:\n<code>history | tail</code>, then refine.\n</div>\n\n<p><span class=\"pill\">Pro tools you’ll adopt</span> <code>tmux</code>, <code>fzf</code>, <code>ripgrep</code>, <code>bat</code>, <code>fd</code>, <code>jq</code>, <code>ssh</code>, <code>git</code></p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "What does `2> err.txt` do?",
        "choices": [
          "Redirect stdout to err.txt",
          "Redirect stderr to err.txt",
          "Append stdout to err.txt",
          "Pipe stderr to the next command"
        ],
        "answerIndex": 1,
        "explanation": "File descriptor 2 is stderr, so `2>` redirects stderr."
      },
      {
        "type": "short",
        "prompt": "What command shows your recent command history tail?",
        "answer": "history | tail",
        "explanation": "This gives a quick scratchpad of recent commands."
      }
    ]
  },
  {
    "id": "navigation",
    "module": "1. Movement & Discovery",
    "title": "Navigation: files, paths, and fast jumping",
    "tags": [
      "fundamentals",
      "filesystem"
    ],
    "content": "\n<p>Learn to move like a native:</p>\n<ul>\n  <li><code>pwd</code>, <code>ls</code>, <code>cd</code> basics — but the pro upgrades are <code>eza</code>, <code>zoxide</code>, and fuzzy finding.</li>\n  <li>Use <code>pushd</code>/<code>popd</code> like a stack for directories.</li>\n</ul>\n\n<div class=\"grid2\">\n<pre>\nFilesystem tree mental model:\n\n/ (root)\n├─ home/\n│  ├─ you/\n│  │  ├─ projects/\n│  │  └─ downloads/\n├─ dev/\n├─ proc/\n└─ etc/\n   ├─ ssh/\n   └─ systemd/\n</pre>\n\n<pre>\nFast jumping (recommended):\n\nzoxide (z) remembers directories:\n  z proj\n  z iso\n\nfzf fuzzy search:\n  cd \"$(find . -type d | fzf)\"\n</pre>\n</div>\n\n<div class=\"hint warn\">\nIf you install one “quality of life” tool first, make it <b>fzf</b>. It upgrades everything.\n</div>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "What does `pushd`/`popd` help with?",
        "choices": [
          "File permissions",
          "Directory stack navigation",
          "Process signals",
          "Port scanning"
        ],
        "answerIndex": 1,
        "explanation": "They manage a stack of directories for quick jumping."
      },
      {
        "type": "short",
        "prompt": "Use zoxide to jump to a folder remembered as proj.",
        "answer": "z proj",
        "explanation": "zoxide stores weighted directory history."
      }
    ]
  },
  {
    "id": "help",
    "module": "2. Reading the System",
    "title": "Getting help: man, tldr, and discoverability",
    "tags": [
      "fundamentals",
      "docs"
    ],
    "content": "\n<p>Pros don’t guess. They query documentation fast.</p>\n<ul>\n  <li><code>man rsync</code> (full manual)</li>\n  <li><code>tldr rsync</code> (quick examples)</li>\n  <li><code>command --help</code> (fast flags overview)</li>\n  <li><code>apropos keyword</code> or <code>man -k keyword</code></li>\n</ul>\n\n<pre>\nASCII: How to learn a command in 30 seconds\n\n1) tldr curl\n2) man curl  (search inside man: /pattern)\n3) try a tiny example\n4) add flags one at a time\n</pre>\n\n<p><span class=\"pill\">Pro libraries/tools</span> <code>tldr</code>, <code>man</code>, <code>info</code>, <code>cheat</code></p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Which command lists manuals matching a keyword?",
        "choices": [
          "whereis keyword",
          "man -k keyword",
          "help keyword",
          "which keyword"
        ],
        "answerIndex": 1,
        "explanation": "`man -k` (or apropos) searches man page names/descriptions."
      },
      {
        "type": "short",
        "prompt": "Open the quick examples for curl.",
        "answer": "tldr curl",
        "explanation": "tldr provides concise examples."
      }
    ]
  },
  {
    "id": "text",
    "module": "3. Text as Data",
    "title": "Pipes, grep, rg, awk, sed, sort, uniq",
    "tags": [
      "text",
      "search"
    ],
    "content": "\n<p>Your superpower: turn text streams into answers.</p>\n\n<div class=\"grid2\">\n<pre>\nPipeline anatomy:\n\ncat file.txt\n| rg \"error|warn\"\n| sort\n| uniq -c\n| sort -nr\n</pre>\n\n<pre>\nModern defaults:\n\nrg  = ripgrep (faster grep)\nfd  = friendlier find\nbat = better cat (syntax highlighting)\n</pre>\n</div>\n\n<p>Practice drills:</p>\n<ul>\n  <li>Find all TODOs: <code>rg -n \"TODO|FIXME\" .</code></li>\n  <li>Top 20 largest files: <code>du -ah . | sort -hr | head -20</code></li>\n  <li>Extract a column: <code>awk '{print $2}'</code></li>\n</ul>\n\n<div class=\"hint\">\nWhen you’re stuck: print intermediate output after each pipe step.\n</div>\n\n<p><span class=\"pill\">Pro libraries/tools</span> <code>ripgrep (rg)</code>, <code>awk</code>, <code>sed</code>, <code>sort</code>, <code>uniq</code>, <code>column</code></p>\n",
    "quiz": [
      {
        "type": "short",
        "prompt": "Find TODO recursively with line numbers in current folder.",
        "answer": "rg -n \"TODO\" .",
        "explanation": "ripgrep is recursive by default; -n prints line numbers."
      },
      {
        "type": "output",
        "prompt": "Predict output for `printf \"a\\na\\nb\\n\" | sort | uniq -c`",
        "answer": "      2 a\n      1 b",
        "explanation": "sort groups lines; uniq -c counts adjacent duplicates."
      }
    ]
  },
  {
    "id": "globbing",
    "module": "4. Shell Power",
    "title": "Globs, quoting, variables, and exit codes",
    "tags": [
      "shell",
      "fundamentals"
    ],
    "content": "\n<p>This is where most “not quite expert” users break things. Learn these rules:</p>\n\n<pre>\nGlobs (shell expands them):\n\n*.log     matches log files\n**/*.js   recursive glob (depends on shell)\n{a,b}.txt brace expansion -> a.txt b.txt\n\nQuoting:\n\"...\" keeps spaces, still expands $VARS\n'...' literal (no expansions)\n\\ escapes next character\n</pre>\n\n<pre>\nExit codes:\n\n0   success\n!=0 failure\n\nChain logic:\ncmd1 && cmd2   (only run cmd2 if cmd1 succeeded)\ncmd1 || cmd2   (run cmd2 if cmd1 failed)\n</pre>\n\n<div class=\"hint danger\">\nIf a path might contain spaces, quote it: <code>\"$path\"</code>\n</div>\n\n<p><span class=\"pill\">Pro libraries/tools</span> <code>shellcheck</code> (lint), <code>bash</code>/<code>zsh</code>, <code>direnv</code> (env per folder)</p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Which quote type prevents variable expansion?",
        "choices": [
          "Double quotes \"...\"",
          "Single quotes '...'",
          "Backticks",
          "No quotes"
        ],
        "answerIndex": 1,
        "explanation": "Single quotes keep content literal in shell."
      },
      {
        "type": "short",
        "prompt": "Write a safe command to list a path stored in variable path that might contain spaces.",
        "answer": "ls \"$path\"",
        "explanation": "Quote variables that may include spaces."
      }
    ]
  },
  {
    "id": "permissions",
    "module": "5. Ownership & Permissions",
    "title": "chmod, chown, umask (and why sudo is not a hammer)",
    "tags": [
      "security",
      "filesystem"
    ],
    "content": "\n<p>Permissions are a 3×3 grid: <b>user</b>, <b>group</b>, <b>others</b> with <b>rwx</b>.</p>\n\n<pre>\nPermissions grid:\n\n        r  w  x\nuser    1  1  1\ngroup   1  0  1\nother   0  0  0\n\n-rwxr-x---  file\n ^^^ ^^^ ^^^\n u   g   o\n\nOctal map: r=4 w=2 x=1\n7=rwx 5=r-x 0=---\n\nchmod 750 file\n</pre>\n\n<pre>\nOwnership flow:\n\n[user alice] ---- member of ----> [devops group]\n      |                              |\n owns deploy.sh                 can read logs/\n\nchown alice:devops deploy.sh\n</pre>\n\n<ul>\n  <li><code>chown user:group file</code></li>\n  <li><code>umask</code> controls default permission masking</li>\n  <li>Prefer least privilege over “sudo everything”</li>\n</ul>\n\n<div class=\"hint warn\">\nA strong pro habit: understand who owns a file before fixing it.\nTry: <code>ls -la</code>\n</div>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "What does chmod 750 grant to group?",
        "choices": [
          "rwx",
          "r-x",
          "rw-",
          "---"
        ],
        "answerIndex": 1,
        "explanation": "7 user=rwx, 5 group=r-x, 0 others=---."
      },
      {
        "type": "short",
        "prompt": "Set owner user and group devops on deploy.sh.",
        "answer": "chown user:devops deploy.sh",
        "explanation": "Format is chown user:group file."
      }
    ]
  },
  {
    "id": "processes",
    "module": "6. Processes & Performance",
    "title": "ps, top/htop, kill, signals, jobs",
    "tags": [
      "process",
      "performance"
    ],
    "content": "\n<p>Learn how Linux runs your programs.</p>\n\n<div class=\"grid2\">\n<pre>\nProcess tree + signals flow:\n\nterminal ---- spawns ----> shell ---- spawns ----> program\n   |                          |\n Ctrl+C                    jobs/bg/fg\n   |\n sends SIGINT --------------> program\n\nInspect:\nps aux | rg node\npstree -p\n\nSignals:\nSIGINT, SIGTERM, SIGKILL\n</pre>\n\n<pre>\nJobs (in your shell):\n\ncmd &\njobs\nfg %1\nbg %1\ndisown\n</pre>\n</div>\n\n<p><span class=\"pill\">Pro libraries/tools</span> <code>htop</code>/<code>btop</code>, <code>strace</code>, <code>lsof</code>, <code>time</code></p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Ctrl+C usually sends which signal?",
        "choices": [
          "SIGTERM",
          "SIGKILL",
          "SIGINT",
          "SIGHUP"
        ],
        "answerIndex": 2,
        "explanation": "Interactive interrupt is SIGINT."
      },
      {
        "type": "short",
        "prompt": "Bring first background job to foreground.",
        "answer": "fg %1",
        "explanation": "job spec `%1` targets the first job."
      }
    ]
  },
  {
    "id": "networking",
    "module": "7. Networking Basics",
    "title": "curl, wget, ssh, scp/rsync, ports and DNS",
    "tags": [
      "network",
      "security"
    ],
    "content": "\n<p>Terminal pros can diagnose network issues quickly.</p>\n\n<pre>\nNetworking path:\n\nyou -> DNS -> IP -> TCP handshake -> service:port -> response\n         |                        |\n      name->addr               443/22/80\n\nSocket map:\nclient:ephemeral_port -> server:443\n</pre>\n\n<pre>\nPorts cheat:\n\n22  -> SSH\n80  -> HTTP\n443 -> HTTPS\n53  -> DNS\n</pre>\n\n<ul>\n  <li><code>curl -I https://example.com</code> headers</li>\n  <li><code>dig example.com</code> DNS query</li>\n  <li><code>ss -tulpn</code> listening ports</li>\n  <li><code>ssh user@host</code> remote shell</li>\n  <li><code>rsync -avz</code> fast sync, resumable</li>\n</ul>\n\n<p><span class=\"pill\">Pro libraries/tools</span> <code>openssh</code>, <code>rsync</code>, <code>mtr</code>, <code>tcpdump</code>, <code>nmap</code> (responsible use)</p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Default SSH port is:",
        "choices": [
          "80",
          "22",
          "443",
          "53"
        ],
        "answerIndex": 1,
        "explanation": "SSH listens on TCP 22 by default."
      },
      {
        "type": "short",
        "prompt": "List listening ports and processes.",
        "answer": "ss -tulpn",
        "explanation": "ss provides socket and process details."
      }
    ]
  },
  {
    "id": "git",
    "module": "8. Version Control",
    "title": "Git fundamentals for terminal workflow",
    "tags": [
      "git",
      "workflow"
    ],
    "content": "\n<p>If you build anything (you do), git is part of being a terminal pro.</p>\n\n<pre>\nCore loop:\ngit status\ngit diff\ngit add -p\ngit commit -m \"message\"\ngit push\n</pre>\n\n<pre>\nASCII: commits are a chain\n\nA -- B -- C -- D (main)\n      \\\n       E -- F     (feature)\n</pre>\n\n<p>Recommended tools:</p>\n<ul>\n  <li><code>delta</code> for nicer diffs</li>\n  <li><code>lazygit</code> if you like a terminal UI</li>\n</ul>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Which command stages patches interactively?",
        "choices": [
          "git add -p",
          "git stage all",
          "git patch",
          "git commit -p"
        ],
        "answerIndex": 0,
        "explanation": "`git add -p` lets you stage hunks."
      },
      {
        "type": "short",
        "prompt": "Check repo state before committing.",
        "answer": "git status",
        "explanation": "Always inspect status before changes."
      }
    ]
  },
  {
    "id": "tmux",
    "module": "9. Multiplexing",
    "title": "tmux: sessions, panes, and muscle memory",
    "tags": [
      "workflow",
      "tmux"
    ],
    "content": "\n<p><b>tmux</b> is how terminal pros keep context and speed.</p>\n\n<pre>\ntmux model:\n\nsession: work\n  ├─ window: editor\n  │   ├─ pane 1\n  │   └─ pane 2\n  └─ window: logs\n      └─ pane 3\n\n+---------------------------+\n| pane 1       | pane 2     |\n|--------------+------------|\n| pane 3                    |\n+---------------------------+\n</pre>\n\n<pre>\nKey chords map:\n\nCtrl+b c   new window\nCtrl+b %   split vertical\nCtrl+b \"   split horizontal\nCtrl+b o   rotate panes\n</pre>\n\n<ul>\n  <li>Start: <code>tmux</code></li>\n  <li>New session: <code>tmux new -s work</code></li>\n  <li>Detach: <code>Ctrl+b</code> then <code>d</code></li>\n  <li>Reattach: <code>tmux a -t work</code></li>\n</ul>\n\n<div class=\"hint\">\nPro tip: keep one session per project: <code>work</code>, <code>infra</code>, <code>notes</code>.\n</div>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "tmux key chord for new window (default prefix)?",
        "choices": [
          "Ctrl+b c",
          "Ctrl+b %",
          "Ctrl+b o",
          "Ctrl+b d"
        ],
        "answerIndex": 0,
        "explanation": "Prefix Ctrl+b then c creates a window."
      },
      {
        "type": "short",
        "prompt": "Reattach to tmux session named work.",
        "answer": "tmux a -t work",
        "explanation": "`a` is shorthand for attach."
      }
    ]
  },
  {
    "id": "dotfiles",
    "module": "10. Professional Setup",
    "title": "Dotfiles: shell config, prompt, aliases, and safety rails",
    "tags": [
      "workflow",
      "shell",
      "security"
    ],
    "content": "\n<p>Pros build guardrails and repeatability.</p>\n\n<ul>\n  <li><b>Shell</b>: bash or zsh</li>\n  <li><b>Prompt</b>: starship (fast, cross-shell)</li>\n  <li><b>Aliases</b>: short and safe (avoid hidden magic)</li>\n  <li><b>Functions</b>: for workflows (git, ssh, logs)</li>\n</ul>\n\n<pre>\nRecommended \"safe defaults\" aliases:\n\nalias rm='rm -i'\nalias cp='cp -i'\nalias mv='mv -i'\n\n# Better tools:\nalias cat='bat'\nalias ls='eza -lah'\n</pre>\n\n<p><span class=\"pill\">Pro libraries/tools</span> <code>starship</code>, <code>zoxide</code>, <code>direnv</code>, <code>chezmoi</code> (dotfiles mgmt)</p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Which alias is a safety rail for delete?",
        "choices": [
          "alias rm='rm -i'",
          "alias rm='rm -rf'",
          "alias cp='cp -r'",
          "alias mv='mv -f'"
        ],
        "answerIndex": 0,
        "explanation": "Interactive rm helps avoid accidental deletion."
      },
      {
        "type": "short",
        "prompt": "Set safer copy alias from the lesson.",
        "answer": "alias cp='cp -i'",
        "explanation": "-i prompts before overwrite."
      }
    ]
  },
  {
    "id": "parsing",
    "module": "11. Structured Data",
    "title": "jq, yq, and logs (JSON/YAML as first-class)",
    "tags": [
      "data",
      "logs"
    ],
    "content": "\n<p>Modern ops/dev work is JSON everywhere. Learn <b>jq</b>.</p>\n\n<pre>\nExtract fields:\ncat file.json | jq '.items[] | {id, name}'\n\nFilter:\njq '.items[] | select(.status==\"error\")'\n</pre>\n\n<p>YAML tools vary; <code>yq</code> is common.</p>\n\n<p><span class=\"pill\">Pro libraries/tools</span> <code>jq</code>, <code>yq</code>, <code>python</code> (quick one-liners), <code>gron</code></p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Which tool is designed to query JSON on CLI?",
        "choices": [
          "awk",
          "jq",
          "grep",
          "sed"
        ],
        "answerIndex": 1,
        "explanation": "jq is purpose-built for JSON."
      },
      {
        "type": "short",
        "prompt": "Select error-status items with jq (assuming array at .items).",
        "answer": "jq \".items[] | select(.status==\"error\")\"",
        "explanation": "Select filters objects by predicate."
      }
    ]
  },
  {
    "id": "scripting",
    "module": "12. Scripting",
    "title": "Write reliable shell scripts (and avoid footguns)",
    "tags": [
      "shell",
      "automation",
      "security"
    ],
    "content": "\n<p>Script like a pro: predictable, safe, tested.</p>\n\n<pre>\nBaseline script headers:\n\n#!/usr/bin/env bash\nset -euo pipefail\nIFS=$'\\n\\t'\n</pre>\n\n<ul>\n  <li><code>shellcheck</code> everything</li>\n  <li>Prefer <code>printf</code> over <code>echo</code> for portability</li>\n  <li>Handle paths safely; quote variables</li>\n</ul>\n\n<div class=\"hint danger\">\nIf you ever write: <code>rm -rf $VAR</code>\n…you must ensure VAR is never empty. Consider checks.\n</div>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Which strict-mode header is recommended?",
        "choices": [
          "set -x",
          "set -euo pipefail",
          "set +e",
          "set -f"
        ],
        "answerIndex": 1,
        "explanation": "`set -euo pipefail` is the baseline here."
      },
      {
        "type": "short",
        "prompt": "What command should you run to lint shell scripts?",
        "answer": "shellcheck script.sh",
        "explanation": "shellcheck catches common shell bugs."
      }
    ]
  },
  {
    "id": "tools",
    "module": "13. Pro Toolbox",
    "title": "The typical terminal-pro library stack",
    "tags": [
      "workflow",
      "tools"
    ],
    "content": "\n<p>This is a pragmatic “pro stack” you’ll see in modern setups:</p>\n\n<div class=\"grid2\">\n<pre>\nSearch & navigate:\n  fzf, ripgrep (rg), fd, zoxide\n\nViewing:\n  bat, eza, less (with -R), delta\n\nSessions:\n  tmux\n\nData:\n  jq, yq\n\nDev:\n  git, gh (GitHub CLI), make\n\nQuality:\n  shellcheck, shfmt\n\nOps:\n  ssh, rsync, curl, wget\n</pre>\n\n<pre>\nMonitoring/debug:\n  htop/btop\n  lsof\n  strace\n  dmesg, journalctl\n  nc (netcat)\n</pre>\n</div>\n\n<p class=\"hint\">\nYou don’t need them all on day 1. Learn in layers:\n<b>rg + fzf + tmux</b> will 10× your speed quickly.\n</p>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Which trio gives the fastest day-one speedup?",
        "choices": [
          "curl + ssh + rsync",
          "rg + fzf + tmux",
          "jq + yq + python",
          "git + gh + make"
        ],
        "answerIndex": 1,
        "explanation": "The lesson calls out rg + fzf + tmux."
      },
      {
        "type": "short",
        "prompt": "Name one monitoring tool from the toolbox section.",
        "answer": "htop",
        "explanation": "Any listed tool (e.g., htop, lsof, strace) is valid."
      }
    ]
  },
  {
    "id": "challenge",
    "module": "14. Practice Path",
    "title": "30-day drills to become dangerous (in a good way)",
    "tags": [
      "practice",
      "workflow"
    ],
    "content": "\n<p>Here’s a simple training plan:</p>\n\n<ul>\n  <li><b>Days 1–5</b>: navigation + pipes (<code>rg</code>, <code>fd</code>, <code>sort</code>, <code>awk</code>)</li>\n  <li><b>Days 6–10</b>: permissions + processes (<code>chmod</code>, <code>ps</code>, <code>kill</code>, <code>lsof</code>)</li>\n  <li><b>Days 11–15</b>: networking (<code>curl</code>, <code>ssh</code>, <code>rsync</code>, <code>ss</code>)</li>\n  <li><b>Days 16–20</b>: tmux + dotfiles (speed & repeatability)</li>\n  <li><b>Days 21–30</b>: write scripts + automate (lint with shellcheck)</li>\n</ul>\n\n<pre>\nASCII: skill stack\n\n      [automation/scripts]\n   [data parsing + networking]\n [process + permissions + text]\n     [navigation + shell]\n</pre>\n\n<div class=\"hint\">\nPick one “real” project (e.g. log analysis, backups, deploy script) and build it over the month.\n</div>\n",
    "quiz": [
      {
        "type": "mcq",
        "prompt": "Days 11–15 focus on which area?",
        "choices": [
          "Git workflows",
          "Networking",
          "Dotfiles",
          "Permissions"
        ],
        "answerIndex": 1,
        "explanation": "The plan explicitly assigns networking to days 11–15."
      },
      {
        "type": "short",
        "prompt": "What should you pick and build over the month?",
        "answer": "one real project",
        "explanation": "A real project compounds skills across lessons."
      }
    ]
  }
]
